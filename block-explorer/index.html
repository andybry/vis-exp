<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>Document</title>
    <style>
      table,
      th,
      td {
        border: 1px solid black;
        border-collapse: collapse;
      }

      th,
      td {
        padding: 15px;
      }
      div {
        padding: 15px;
      }
      label {
        margin: 10px;
      }
    </style>
  </head>
  <body>
    <div id="app"></div>
    <script
      crossorigin
      src="https://unpkg.com/react@16/umd/react.production.min.js"
    ></script>
    <script
      crossorigin
      src="https://unpkg.com/react-dom@16/umd/react-dom.production.min.js"
    ></script>
    <script crossorigin src="http://unpkg.com/web3/dist/web3.min.js"></script>
    <script crossorigin src="http://unpkg.com/@babel/standalone"></script>
    <script type="text/babel">
      const web3 = new Web3(ethereum)
      const hash = web3.utils.sha3

      const CONTRACTS = {
        EVENTS_MANAGER: 'IEventsManager',
        AVT_MANAGER: 'IAVTManager',
        VALIDATORS_MANAGER: 'IValidatorsManager',
        MERKLE_ROOTS_MANAGER: 'IMerkleRootsManager'
      }

      class Storage {
        constructor(contract, version) {
          this.contract = contract
          this.methods = contract.methods
          this.version = version
        }

        static async create(url, address, version) {
          const res = await fetch(url)
          const { abi } = await res.json()
          const contract = new web3.eth.Contract(abi, address)
          return new Storage(contract, version)
        }

        withVersion(str) {
          return `${str}-${this.version}`
        }

        call(method, ...args) {
          return this.methods[method](...args).call()
        }

        async address(str) {
          return this.call('getAddress', hash(str))
        }

        async uint(str) {
          return this.call('getUInt', hash(str))
        }

        async string(str) {
          return this.call('getString', hash(str))
        }

        async getContract(str) {
          const withVersion = this.withVersion(str)
          const address = await this.address(`${withVersion}_Address`)
          const n = await this.uint(`${withVersion}_Abi_NumParts`)
          const ps = []
          for (let i = 0; i < n; i++)
            ps.push(this.string(`${withVersion}_Abi_Part_${i}`))
          const parts = await Promise.all(ps)
          const abi = JSON.parse(parts.join(''))
          return new web3.eth.Contract(abi, address)
        }
      }

      class Event {
        constructor(data) {
          this.id = data.id
          this.event = data.event
          this.signature = data.signature
          this.address = data.address
          this.blockNumber = data.blockNumber
          this.transactionHash = data.transactionHash
          this.dynamic = {}
          for (const key in data.returnValues) {
            if (!key.match(/\d+/g)) this.dynamic[key] = data.returnValues[key]
          }
        }
      }

      class App extends React.Component {
        constructor(props) {
          super(props)
          this.state = {
            events: [],
            start: 0,
            end: 50,
            filter: '',
            value: ''
          }
          this.changeStart = this.changeStart.bind(this)
          this.changeEnd = this.changeEnd.bind(this)
          this.changeFilter = this.changeFilter.bind(this)
          this.changeValue = this.changeValue.bind(this)
        }

        async componentDidMount() {
          const url =
            'https://raw.githubusercontent.com/AventusProtocolFoundation/protocol/master/api/storage.json'
          const version = '0.14'
          const network = await web3.eth.net.getNetworkType()
          console.log(network)
          const address =
            network === 'rinkeby'
              ? '0x66E6f6c64e702840e11fDaB052de04Bede06c92D'
              : '0xd6589f7CB6AE49f77ee9F666fF8AB84a91c07133'
          const storage = await Storage.create(url, address, version)
          const contract = await storage.getContract(
            CONTRACTS.MERKLE_ROOTS_MANAGER
          )
          const subscribers = [
            contract.events.LogMerkleRootRegistered,
            contract.events.LogMerkleRootDeregistered
          ]
          this.subscriptions = subscribers.map(f => f({ fromBlock: 5700000 }))
          this.subscriptions.forEach(sub => {
            let buffer = []
            let timeout = null
            sub.on('data', data => {
              buffer.unshift(new Event(data))
              if (timeout) clearTimeout(interval)
              setTimeout(() => {
                this.setState(state => {
                  return {
                    events: [...buffer, ...state.events]
                  }
                })
                buffer = []
              }, 100)
            })
          })
        }

        componentWillUnmount() {
          this.subscriptions.forEach(sub => sub.unsubscribe())
        }

        changeStart(e) {
          this.setState({ start: e.target.value })
        }

        changeEnd(e) {
          this.setState({ end: e.target.value })
        }

        changeFilter(e) {
          this.setState({ filter: e.target.value })
        }

        changeValue(e) {
          this.setState({ value: e.target.value })
        }

        render() {
          const { events, start, end, filter, value } = this.state
          if (events.length === 0) return <div>Loading...</div>

          const headers = []
          const headerRow = []
          const rows = []
          let filteredResults = []
          if (filter) {
            const parts = filter.split('.')
            filteredResults = events.filter(event => {
              let item = event
              for (const part of parts) item = item ? item[part] : item
              return item === value
            })
          }
          const tableEvents = (filteredResults.length > 0
            ? filteredResults
            : events
          ).slice(start, end)
          for (const header in events[0]) headers.push(header)
          for (const header of headers)
            headerRow.push(<th key={header}>{header}</th>)
          for (const event of tableEvents) {
            const tds = []
            for (const header of headers)
              tds.push(
                <td key={header}>
                  {typeof event[header] === 'object' ? (
                    <pre>{JSON.stringify(event[header], null, 2)}</pre>
                  ) : (
                    event[header]
                  )}
                </td>
              )
            rows.push(<tr key={event.id}>{tds}</tr>)
          }
          return (
            <div>
              <div>Total Results: {events.length}</div>
              <div>Filtered Results: {filteredResults.length}</div>
              <div>
                <label>
                  Start Index:{' '}
                  <input
                    value={start}
                    type="number"
                    onChange={this.changeStart}
                  />
                </label>
                <label>
                  End Index:{' '}
                  <input value={end} type="number" onChange={this.changeEnd} />
                </label>
              </div>
              <div>
                <label>
                  Filter:{' '}
                  <input
                    value={filter}
                    type="text"
                    onChange={this.changeFilter}
                  />
                </label>
                <label>
                  Value:{' '}
                  <input
                    value={value}
                    type="text"
                    onChange={this.changeValue}
                  />
                </label>
              </div>
              <table>
                <thead>
                  <tr>{headerRow}</tr>
                </thead>
                <tbody>{rows}</tbody>
              </table>
            </div>
          )
        }
      }

      ReactDOM.render(<App />, document.getElementById('app'))
    </script>
  </body>
</html>
